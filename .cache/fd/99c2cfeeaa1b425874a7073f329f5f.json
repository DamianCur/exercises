{"id":"../../node_modules/ts-node/dist/configuration.js","dependencies":[{"name":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\configuration.js.map","includedInParent":true,"mtime":1644349660424},{"name":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\package.json","includedInParent":true,"mtime":1645658055197},{"name":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\package.json","includedInParent":true,"mtime":1644349660269},{"name":"path","loc":{"line":15,"column":23,"index":620},"parent":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\configuration.js","resolved":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\path-browserify\\index.js"},{"name":"./index","loc":{"line":16,"column":24,"index":653},"parent":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\configuration.js","resolved":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\index.js"},{"name":"./ts-internals","loc":{"line":17,"column":31,"index":696},"parent":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\configuration.js","resolved":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\ts-internals.js"},{"name":"./tsconfigs","loc":{"line":18,"column":28,"index":743},"parent":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\configuration.js","resolved":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\tsconfigs.js"},{"name":"./util","loc":{"line":19,"column":23,"index":782},"parent":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\configuration.js","resolved":"C:\\Users\\1420d\\OneDrive\\Desktop\\LHA_TS - EXERCISES\\node_modules\\ts-node\\dist\\util.js"}],"generated":{"js":"\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readConfig = void 0;\nconst path_1 = require(\"path\");\nconst index_1 = require(\"./index\");\nconst ts_internals_1 = require(\"./ts-internals\");\nconst tsconfigs_1 = require(\"./tsconfigs\");\nconst util_1 = require(\"./util\");\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n    sourceMap: true,\n    inlineSourceMap: false,\n    inlineSources: true,\n    declaration: false,\n    noEmit: false,\n    outDir: '.ts-node',\n};\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts, config) {\n    // Delete options that *should not* be passed through.\n    delete config.options.out;\n    delete config.options.outFile;\n    delete config.options.composite;\n    delete config.options.declarationDir;\n    delete config.options.declarationMap;\n    delete config.options.emitDeclarationOnly;\n    // Target ES5 output by default (instead of ES3).\n    if (config.options.target === undefined) {\n        config.options.target = ts.ScriptTarget.ES5;\n    }\n    // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n    if (config.options.module === undefined) {\n        config.options.module = ts.ModuleKind.CommonJS;\n    }\n    return config;\n}\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nfunction readConfig(cwd, ts, rawApiOptions) {\n    var _a, _b, _c;\n    // Ordered [a, b, c] where config a extends b extends c\n    const configChain = [];\n    let config = { compilerOptions: {} };\n    let basePath = cwd;\n    let configFilePath = undefined;\n    const projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);\n    const { fileExists = ts.sys.fileExists, readFile = ts.sys.readFile, skipProject = index_1.DEFAULTS.skipProject, project = index_1.DEFAULTS.project, } = rawApiOptions;\n    // Read project configuration when available.\n    if (!skipProject) {\n        configFilePath = project\n            ? (0, path_1.resolve)(cwd, project)\n            : ts.findConfigFile(projectSearchDir, fileExists);\n        if (configFilePath) {\n            let pathToNextConfigInChain = configFilePath;\n            const tsInternals = (0, ts_internals_1.createTsInternals)(ts);\n            const errors = [];\n            // Follow chain of \"extends\"\n            while (true) {\n                const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n                // Return diagnostics.\n                if (result.error) {\n                    return {\n                        configFilePath,\n                        config: { errors: [result.error], fileNames: [], options: {} },\n                        tsNodeOptionsFromTsconfig: {},\n                        optionBasePaths: {},\n                    };\n                }\n                const c = result.config;\n                const bp = (0, path_1.dirname)(pathToNextConfigInChain);\n                configChain.push({\n                    config: c,\n                    basePath: bp,\n                    configPath: pathToNextConfigInChain,\n                });\n                if (c.extends == null)\n                    break;\n                const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {\n                    fileExists,\n                    readDirectory: ts.sys.readDirectory,\n                    readFile,\n                    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n                    trace: util_1.trace,\n                }, bp, errors, ts.createCompilerDiagnostic);\n                if (errors.length) {\n                    return {\n                        configFilePath,\n                        config: { errors, fileNames: [], options: {} },\n                        tsNodeOptionsFromTsconfig: {},\n                        optionBasePaths: {},\n                    };\n                }\n                if (resolvedExtendedConfigPath == null)\n                    break;\n                pathToNextConfigInChain = resolvedExtendedConfigPath;\n            }\n            ({ config, basePath } = configChain[0]);\n        }\n    }\n    // Merge and fix ts-node options that come from tsconfig.json(s)\n    const tsNodeOptionsFromTsconfig = {};\n    const optionBasePaths = {};\n    for (let i = configChain.length - 1; i >= 0; i--) {\n        const { config, basePath, configPath } = configChain[i];\n        const options = filterRecognizedTsConfigTsNodeOptions(config['ts-node'])\n            .recognized;\n        // Some options are relative to the config file, so must be converted to absolute paths here\n        if (options.require) {\n            // Modules are found relative to the tsconfig file, not the `dir` option\n            const tsconfigRelativeRequire = (0, util_1.createRequire)(configPath);\n            options.require = options.require.map((path) => tsconfigRelativeRequire.resolve(path));\n        }\n        if (options.scopeDir) {\n            options.scopeDir = (0, path_1.resolve)(basePath, options.scopeDir);\n        }\n        // Downstream code uses the basePath; we do not do that here.\n        if (options.moduleTypes) {\n            optionBasePaths.moduleTypes = basePath;\n        }\n        (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);\n    }\n    // Remove resolution of \"files\".\n    const files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files;\n    if (!files) {\n        config.files = [];\n        config.include = [];\n    }\n    // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n    const skipDefaultCompilerOptions = configFilePath != null;\n    const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions\n        ? undefined\n        : Object.assign(Object.assign({}, (0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions), { types: ['node'] });\n    // Merge compilerOptions from all sources\n    config.compilerOptions = Object.assign({}, \n    // automatically-applied options from @tsconfig/bases\n    defaultCompilerOptionsForNodeVersion, \n    // tsconfig.json \"compilerOptions\"\n    config.compilerOptions, \n    // from env var\n    index_1.DEFAULTS.compilerOptions, \n    // tsconfig.json \"ts-node\": \"compilerOptions\"\n    tsNodeOptionsFromTsconfig.compilerOptions, \n    // passed programmatically\n    rawApiOptions.compilerOptions, \n    // overrides required by ts-node, cannot be changed\n    TS_NODE_COMPILER_OPTIONS);\n    const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n        fileExists,\n        readFile,\n        readDirectory: ts.sys.readDirectory,\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n    }, basePath, undefined, configFilePath));\n    return {\n        configFilePath,\n        config: fixedConfig,\n        tsNodeOptionsFromTsconfig,\n        optionBasePaths,\n    };\n}\nexports.readConfig = readConfig;\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject) {\n    if (jsonObject == null)\n        return { recognized: {}, unrecognized: {} };\n    const _a = jsonObject, { compiler, compilerHost, compilerOptions, emit, files, ignore, ignoreDiagnostics, logError, preferTsExts, pretty, require, skipIgnore, transpileOnly, typeCheck, transpiler, scope, scopeDir, moduleTypes, experimentalReplAwait } = _a, unrecognized = __rest(_a, [\"compiler\", \"compilerHost\", \"compilerOptions\", \"emit\", \"files\", \"ignore\", \"ignoreDiagnostics\", \"logError\", \"preferTsExts\", \"pretty\", \"require\", \"skipIgnore\", \"transpileOnly\", \"typeCheck\", \"transpiler\", \"scope\", \"scopeDir\", \"moduleTypes\", \"experimentalReplAwait\"]);\n    const filteredTsConfigOptions = {\n        compiler,\n        compilerHost,\n        compilerOptions,\n        emit,\n        experimentalReplAwait,\n        files,\n        ignore,\n        ignoreDiagnostics,\n        logError,\n        preferTsExts,\n        pretty,\n        require,\n        skipIgnore,\n        transpileOnly,\n        typeCheck,\n        transpiler,\n        scope,\n        scopeDir,\n        moduleTypes,\n    };\n    // Use the typechecker to make sure this implementation has the correct set of properties\n    const catchExtraneousProps = null;\n    const catchMissingProps = null;\n    return { recognized: filteredTsConfigOptions, unrecognized };\n}\n"},"sourceMaps":{"js":{"version":3,"file":"configuration.js","sourceRoot":"","sources":["../src/configuration.ts"],"names":[],"mappings":"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","sourcesContent":["import { resolve, dirname } from 'path';\nimport type * as _ts from 'typescript';\nimport {\n  CreateOptions,\n  DEFAULTS,\n  OptionBasePaths,\n  TSCommon,\n  TsConfigOptions,\n} from './index';\nimport type { TSInternal } from './ts-compiler-types';\nimport { createTsInternals } from './ts-internals';\nimport { getDefaultTsconfigJsonForNodeVersion } from './tsconfigs';\nimport { assign, createRequire, trace } from './util';\n\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node',\n};\n\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts: TSCommon, config: _ts.ParsedCommandLine) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly;\n\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  }\n\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nexport function readConfig(\n  cwd: string,\n  ts: TSCommon,\n  rawApiOptions: CreateOptions\n): {\n  /**\n   * Path of tsconfig file if one was loaded\n   */\n  configFilePath: string | undefined;\n  /**\n   * Parsed TypeScript configuration with compilerOptions merged from all other sources (env vars, etc)\n   */\n  config: _ts.ParsedCommandLine;\n  /**\n   * ts-node options pulled from `tsconfig.json`, NOT merged with any other sources.  Merging must happen outside\n   * this function.\n   */\n  tsNodeOptionsFromTsconfig: TsConfigOptions;\n  optionBasePaths: OptionBasePaths;\n} {\n  // Ordered [a, b, c] where config a extends b extends c\n  const configChain: Array<{\n    config: any;\n    basePath: string;\n    configPath: string;\n  }> = [];\n  let config: any = { compilerOptions: {} };\n  let basePath = cwd;\n  let configFilePath: string | undefined = undefined;\n  const projectSearchDir = resolve(cwd, rawApiOptions.projectSearchDir ?? cwd);\n\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = DEFAULTS.skipProject,\n    project = DEFAULTS.project,\n  } = rawApiOptions;\n\n  // Read project configuration when available.\n  if (!skipProject) {\n    configFilePath = project\n      ? resolve(cwd, project)\n      : ts.findConfigFile(projectSearchDir, fileExists);\n\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = createTsInternals(ts);\n      const errors: Array<_ts.Diagnostic> = [];\n\n      // Follow chain of \"extends\"\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n\n        // Return diagnostics.\n        if (result.error) {\n          return {\n            configFilePath,\n            config: { errors: [result.error], fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n\n        const c = result.config;\n        const bp = dirname(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain,\n        });\n\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(\n          c.extends,\n          {\n            fileExists,\n            readDirectory: ts.sys.readDirectory,\n            readFile,\n            useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n            trace,\n          },\n          bp,\n          errors,\n          ((ts as unknown) as TSInternal).createCompilerDiagnostic\n        );\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: { errors, fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n\n      ({ config, basePath } = configChain[0]);\n    }\n  }\n\n  // Merge and fix ts-node options that come from tsconfig.json(s)\n  const tsNodeOptionsFromTsconfig: TsConfigOptions = {};\n  const optionBasePaths: OptionBasePaths = {};\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const { config, basePath, configPath } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(config['ts-node'])\n      .recognized;\n\n    // Some options are relative to the config file, so must be converted to absolute paths here\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeRequire = createRequire(configPath);\n      options.require = options.require.map((path: string) =>\n        tsconfigRelativeRequire.resolve(path)\n      );\n    }\n    if (options.scopeDir) {\n      options.scopeDir = resolve(basePath, options.scopeDir!);\n    }\n\n    // Downstream code uses the basePath; we do not do that here.\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n\n    assign(tsNodeOptionsFromTsconfig, options);\n  }\n\n  // Remove resolution of \"files\".\n  const files =\n    rawApiOptions.files ?? tsNodeOptionsFromTsconfig.files ?? DEFAULTS.files;\n  if (!files) {\n    config.files = [];\n    config.include = [];\n  }\n\n  // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions\n    ? undefined\n    : {\n        ...getDefaultTsconfigJsonForNodeVersion(ts).compilerOptions,\n        types: ['node'],\n      };\n\n  // Merge compilerOptions from all sources\n  config.compilerOptions = Object.assign(\n    {},\n    // automatically-applied options from @tsconfig/bases\n    defaultCompilerOptionsForNodeVersion,\n    // tsconfig.json \"compilerOptions\"\n    config.compilerOptions,\n    // from env var\n    DEFAULTS.compilerOptions,\n    // tsconfig.json \"ts-node\": \"compilerOptions\"\n    tsNodeOptionsFromTsconfig.compilerOptions,\n    // passed programmatically\n    rawApiOptions.compilerOptions,\n    // overrides required by ts-node, cannot be changed\n    TS_NODE_COMPILER_OPTIONS\n  );\n\n  const fixedConfig = fixConfig(\n    ts,\n    ts.parseJsonConfigFileContent(\n      config,\n      {\n        fileExists,\n        readFile,\n        readDirectory: ts.sys.readDirectory,\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n      },\n      basePath,\n      undefined,\n      configFilePath\n    )\n  );\n\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths,\n  };\n}\n\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(\n  jsonObject: any\n): {\n  recognized: TsConfigOptions;\n  unrecognized: any;\n} {\n  if (jsonObject == null) return { recognized: {}, unrecognized: {} };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    ...unrecognized\n  } = jsonObject as TsConfigOptions;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n  };\n  // Use the typechecker to make sure this implementation has the correct set of properties\n  const catchExtraneousProps: keyof TsConfigOptions = (null as any) as keyof typeof filteredTsConfigOptions;\n  const catchMissingProps: keyof typeof filteredTsConfigOptions = (null as any) as keyof TsConfigOptions;\n  return { recognized: filteredTsConfigOptions, unrecognized };\n}\n"]}},"error":null,"hash":"170f5ec263097e8b437b03f4b4989f12","cacheData":{"env":{}}}